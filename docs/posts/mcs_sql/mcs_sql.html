<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.41">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jaehyeok Lee">
<meta name="dcterms.date" content="2025-03-19">

<title>MCS SQL Paper Review – Knowledge Log</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-48ffa3e5b9d089919c6712c39e5b00f2.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-66a88d721a32bd99678ac66546d2e927.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&amp;family=Noto+Sans:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Knowledge Log</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Jhyeok-lee"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/%EC%9E%AC%ED%98%81-%EC%9D%B4-270944207/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">MCS SQL Paper Review</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">LLM</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jaehyeok Lee </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 19, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>MCS-SQL, Leveraging Multiple Prompts and Multiple-Choice Selection For Text-to-SQL Generation <a href="https://arxiv.org/pdf/2405.07467">https://arxiv.org/pdf/2405.07467</a></p>
<section id="abstract" class="level1">
<h1>Abstract</h1>
<ul>
<li>이 논문에서는 prompts에 민감한 LLM을 고려해서, 가능한 답변에 대한 더 넓은 탐색 공간을 탐색하고 효과적으로 집계하는 다양한 prompts 활용 방법을 소개</li>
</ul>
</section>
<section id="introduction" class="level1">
<h1>1. Introduction</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="a.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1</figcaption>
</figure>
</div>
<ul>
<li>LLM 기반 in-context learning(ICL)은 SFT보다 text-to-SQL에서 더 나은 성능을 보였다.</li>
<li>BIRD benchmark 처럼 복잡한 스키마와 쿼리에서는 낮은 성능을 보였다.</li>
<li>LLM의 한계점은 prompts의 구조와 컨텐츠에 민감하다는 것이다. 의미적으로 같은 prompts에 대해서도 매우 다른 응답을 생성할 수 있다. 스키마 표현, few-shot 예제의 선택으로 다양한 LLM 결과를 볼 수 있었다.</li>
</ul>
</section>
<section id="methodology" class="level1">
<h1>3. Methodology</h1>
<section id="schema-linking" class="level2">
<h2 class="anchored" data-anchor-id="schema-linking">3.1 Schema Linking</h2>
<ul>
<li>Schema Linking으로 text-to-sql 성능이 많이 오름.</li>
<li>high recall을 목표로 여러 프롬프트를 도입.</li>
</ul>
<section id="table-linking" class="level3">
<h3 class="anchored" data-anchor-id="table-linking">3.1.1 Table Linking</h3>
<ul>
<li>LLM에게 테이블 선택 + 왜 필요한지(CoT) 물음.</li>
<li>JSON 포맷으로 응답하도록 설정</li>
</ul>
<pre><code>### For a given DB schema and question,
extract the list of tables required
to write the SQL query.
### DB schema: ...
### Question: ...

Your answer should be in the json format
:
{
"reasoning": "..." # The reason for
selecting each table.
"answer": [...] # List of selected
tables.
}
### Your answer:</code></pre>
<ul>
<li>테이블과 컬럼 순서에 따라 결과가 달랐음. 이 영향을 최소화하기 위해 테이블 순서를 셔플해서 <span class="math inline">\(p_t\)</span>개의 distinct prompts 생성. 각 prompt마다 n개 응답 생성(높은 sampling temperature 사용). n개의 응답을 union. 그 이유는 필요없는 테이블은 뒤의 프로세스에서 큰 영향이 없지만 필요한 테이블이 없는 것은 영향이 크기 때문.</li>
</ul>
<p><strong>B.1.1 Prompt for Table Linking</strong></p>
<pre><code>### Given a database schema, question, and knowledge evidence, extract a list of
tables that should be referenced to convert the question into SQL.
### SQLite SQL tables, with their properties:
# molecule ( molecule_id, label )
# connected ( atom_id, atom_id2, bond_id )
# bond ( bond_id, molecule_id, bond_type )
# atom ( atom_id, molecule_id, element )
#
# atom.molecule_id = molecule.molecule_id
# bond.molecule_id = molecule.molecule_id
# connected.bond_id = bond.bond_id
# connected.atom_id2 = atom.atom_id
# connected.atom_id = atom.atom_id
### Question: Among all chemical compounds identified in the database, what percent
of compounds form a triple-bond.
### Knowledge Evidence: triple bond refers to bond_type = ’#’;
You need to not only select the required tables, but also explain in detail why each
table is needed.
Your answer should strictly follow the following json format.
{
"reasoning": "", // The reason for choosing each table.
"tables": [], // List of selected tables.
}
### Your Answer:</code></pre>
</section>
<section id="column-linking" class="level3">
<h3 class="anchored" data-anchor-id="column-linking">3.1.2 Column Linking</h3>
<ul>
<li>앞에서 Table Linking의 결과 테이블만 써서 column linking. prompt도 비슷.</li>
<li>같은 컬럼 이름이 존재할 수 있어서 <code>[table_name].[column_name]</code> 포맷으로 응답하게 함.</li>
<li>역시 테이블, 컬럼 순서 셔플해서 prompt <span class="math inline">\(p_c\)</span>개 생성하고 n개 응답 생성 후 union.</li>
<li>SQL Generation에서는 Table, Column Linking 결과만을 제시.</li>
</ul>
<p><strong>B.1.2 Prompt for Column Linking</strong></p>
<pre><code>### Given a database schema, question, and knowledge evidence, extract a list of
columns that should be referenced to convert the question into SQL.
### SQLite SQL tables, with their properties:
# molecule ( molecule_id, label )
# bond ( bond_id, molecule_id, bond_type )
#
# bond.molecule_id = molecule.molecule_id
### Question: Among all chemical compounds identified in the database, what percent
of compounds form a triple-bond.
### Knowledge Evidence: triple bond refers to bond_type = ’#’;
You need to not only select the required columns, but also explain in detail why
each column is needed.
Your answer should strictly follow the following json format.
{{
"reasoning": "", // The reason for choosing each column.
"columns": ["table_name_i.column_name_j", ...], // List of selected columns
}}
### Your Answer:</code></pre>
</section>
</section>
<section id="multiple-sql-generation" class="level2">
<h2 class="anchored" data-anchor-id="multiple-sql-generation">3.2 Multiple SQL Generation</h2>
<ul>
<li>SQL generation 역시 다양한 prompt로 생성.</li>
<li>few-shot examples을 선택과 순서를 다양하게 해서 prompt를 생성.</li>
</ul>
<section id="few-shot-examples-selection" class="level3">
<h3 class="anchored" data-anchor-id="few-shot-examples-selection">3.2.1 Few-Shot Examples Selection</h3>
<ul>
<li>하나의 test sample에 대해 training dataset에서 few-shot examples가 선택된다.</li>
<li>여러 prompts를 만들기 위해 두 가지 전략 사용: question similarity, masked question similarity.</li>
<li>question similarity : test 질문과 가장 가까운 training 질문 top-k개 선택 (sentence embedding)</li>
<li>question에서 DB Schema에 특화된 tokens를 마스킹. 이 방법은 특정 도메인과 관계없이 비슷한 질문을 찾는 데 도움을 줌. LLM을 사용해서 DB Schema와 질문에서 테이블 이름, 컬럼 이름, 값을 special tokens으로 대체.</li>
<li>위 두 가지 방법으로 <span class="math inline">\(p_q\)</span> 개의 prompts를 만드는데, 하나는 오직 question similarity, 다른 것은 masked similarity, 나머지는 두 가지를 합쳐서 다양한 순서로 만듬.</li>
</ul>
<p><strong>B.2 Prompt for Question Masking</strong></p>
<pre><code>### Given a DB schema and a question, mask the table name, column name, and values
in the question.

&lt;example1&gt;
### SQLite SQL tables, with their properties:
# customers ( CustomerID: integer, Segment: text, Currency: text )
# gasstations ( GasStationID: integer, ChainID: integer, Country: text, Segment:
text )
# products ( ProductID: integer, Description: text )
# transactions_1k ( TransactionID: integer, Date: date, Time: text, CustomerID:
integer, CardID: integer, GasStationID: integer, ProductID: integer, Amount:
integer, Price: real )
# yearmonth ( CustomerID: integer, Date: text, Consumption: real )
### Question: For all the people who paid more than 29.00 per unit of product id No
.5. Give their consumption status in the August of 2012.
### Masked Question: For all the [TABLE] who paid more than [VALUE] per unit of [
COLUMN] [VALUE]. Give their consumption status in the [VALUE].
&lt;/example1&gt;

&lt;example2&gt;
### SQLite SQL tables, with their properties:
# customers ( CustomerID: integer, Segment: text, Currency: text )
# gasstations ( GasStationID: integer, ChainID: integer, Country: text, Segment:
text )
# products ( ProductID: integer, Description: text )
# transactions_1k ( TransactionID: integer, Date: date, Time: text, CustomerID:
integer, CardID: integer, GasStationID: integer, ProductID: integer, Amount:
integer, Price: real )
# yearmonth ( CustomerID: integer, Date: text, Consumption: real )
### Question: How much did customer 6 consume in total between August and November
2013?
### Masked Question: How much did [TABLE] [VALUE] consume in total between [VALUE]
and [VALUE]?
&lt;/example2&gt;

&lt;example3&gt;
### SQLite SQL tables, with their properties:
# drivers ( driverId: integer, driverRef: text, number: integer, code: text,
forename: text, surname: text, dob: date, nationality: text, url: text )
### Question: How many Australian drivers who were born in 1980?
### Masked Question: How many [VALUE] [TABLE] who were born in [VALUE]?
&lt;/example3&gt;

### SQLite SQL tables, with their properties:
# molecule ( molecule_id, label )
# bond ( bond_id, molecule_id, bond_type )
#
# bond.molecule_id = molecule.molecule_id
### Question: Among all chemical compounds identified in the database, what percent
of compounds form a triple-bond.
### Knowledge Evidence: triple bond refers to bond_type = ’#’;
### Masked Question:</code></pre>
</section>
<section id="sql-generation" class="level3">
<h3 class="anchored" data-anchor-id="sql-generation">3.2.2 SQL Generation</h3>
<pre><code>### Generate the correct SQL query for a
given DB schema and question.
### Gold Examples:
- Question: ...
- Gold SQL: ...
...

### DB Schema: ...
### Sample Table Contents: ...
### Question: ...
Your answer should be in the json format
:
{
"reasoning": ".." # The reasoning
steps behind the generated SQL query
"sql": ".." # The generated SQL query.
}
### Your answer:</code></pre>
<ul>
<li>prompt에는 few-shot examples, DB schema, sample rows, question이 포함.</li>
<li>few-show examples에는 질문-gold SQL pairs 가 포함.</li>
<li>prompt 길이를 줄이기 위해 schema-linking 결과 테이블과 컬럼만 포함.</li>
<li>CSV 포멧으로 sample rows 포함.</li>
<li>SQL query 뿐만 아니라 reasoning도 생성.</li>
<li><span class="math inline">\(p_q\)</span>개의 prompt, 각 n개 응답 생성. (with a high sampling temperature)</li>
</ul>
<p><strong>B.3 Prompt for SQL Generation</strong></p>
<pre><code>### Given a database schema, question, and knowledge evidence, generate the correct
sqlite SQL query for the question.

&lt;examples&gt;
# Question: Among all the customers, what is the percentage of the customer’s nation
being Germany?
# Knowledge Evidence: DIVIDE(COUNT(c_custkey when n_name = ’GERMANY’), COUNT(
c_custkey)) as percentage;
# Gold SQL: SELECT CAST(SUM(IIF(T2.n_name = ’GERMANY’, 1, 0)) AS REAL) * 100 / COUNT
(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey =
T2.n_nationkey

# Question: Among the schools whose donators are teachers, what is the percentage of
schools that are in Brooklyn?
# Knowledge Evidence: donors are teachers refers to is_teacher_acct = ’t’; Brooklyn
is school_city; percentage = Divide(Count(school_city-’Brooklyn’),Count(
school_city))*100
# Gold SQL: SELECT CAST(SUM(CASE WHEN T1.school_city LIKE ’Brooklyn’ THEN 1 ELSE 0
END) AS REAL) * 100 / COUNT(T1.teacher_acctid) FROM projects AS T1 INNER JOIN
donations AS T2 ON T1.projectid = T2.projectid WHERE T2.is_teacher_acct = ’t’
...
&lt;/examples&gt;

### SQLite SQL tables, with their properties:
# molecule ( molecule_id, label )
# bond ( bond_id, molecule_id, bond_type )
#
# bond.molecule_id = molecule.molecule_id
### The type and description of each column:
# [molecule]
- molecule_id (text): unique id of molecule
- label (text): whether this molecule is carcinogenic or not
# [bond]
- bond_id (text): unique id representing bonds
- molecule_id (text): identifying the molecule in which the bond appears
- bond_type (text): type of the bond
### Sample rows of each table in csv format:
# [molecule]
molecule_id,label
TR000,+
TR001,+
TR002,-
# [bond]
bond_id,molecule_id,bond_type
TR000_1_2,TR000,-
TR000_2_3,TR000,-
TR000_2_4,TR000,-

### Question: Among all chemical compounds identified in the database, what percent
of compounds form a triple-bond.

### Knowledge Evidence: triple bond refers to bond_type = ’#’;
You need to not only create the SQL, but also provide the detailed reasoning steps
required to create the SQL. Your answer should strictly follow the following
json format:
{
"reasoning": "", // The reasoning steps for generating SQL.
"sql": "", // The final generated SQL.
}
### Your Answer:</code></pre>
</section>
</section>
<section id="selection" class="level2">
<h2 class="anchored" data-anchor-id="selection">3.3 Selection</h2>
<ul>
<li>위에서 생성한 SQL을 confidence scores로 필터링하고 LLM에게 가장 정확한 쿼리를 선택하게 한다.</li>
</ul>
<section id="candidate-filtering" class="level3">
<h3 class="anchored" data-anchor-id="candidate-filtering">3.3.1 Candidate Filtering</h3>
<ul>
<li>모든 SQL 쿼리를 실행시켜서 에러, 타임아웃 제외.</li>
<li>각 쿼리마다 confidence score를 계산해서 0.2 이하 제외.</li>
<li>같은 결과를 내는 것들만 묶어서 가장 빠른 쿼리 하나만 남김.</li>
<li>confidence score : self-consistency 체크. 후보 쿼리 N개 중 하나가 다른 쿼리들과 같은 결과를 내는지. <span class="math display">\[
\text{confidence}(q_i)= \frac{1}{N} \sum_{j=1}^N [\text{exec}(q_j) = \text{exec}(q_i)]
\]</span></li>
</ul>
</section>
<section id="multiple-choise-selection-mcs" class="level3">
<h3 class="anchored" data-anchor-id="multiple-choise-selection-mcs">3.3.2 Multiple-Choise Selection (MCS)</h3>
<pre><code>### For a given DB schema and question,
select the most accurate query among
the candidate SQL queries.
### DB schema: ...
### Question: ...
### Candidate SQLs:
1. SQL1
2. SQL2
3. SQL3
Your answer should be in the json format
:
{
"reasoning": ".." # The reasoning
steps for selecting the correct SQL
query.
"sql": ".." # The selected SQL query.
}</code></pre>
<ul>
<li>LLM을 사용해서 위에서 만든 후보 풀에서 가장 정확한 쿼리를 선택.</li>
<li>후보 쿼리들은 confidence scores가 내림차순으로 정렬.</li>
<li>n개의 응답을 생성. 가장 많은 투표를 받은 쿼리 선택.</li>
</ul>
<p><strong>B.4 Prompt for SQL Selection</strong></p>
<pre><code>### When a DB schema, a question, and a knowledge evidence are given, and up to
three SQLite queries expressing the question are given, please choose the most
accurate SQL based on the Checklist.
&lt;examples&gt;
# Question: Among all the customers, what is the percentage of the customer’s nation
being Germany?
# Knowledge Evidence: DIVIDE(COUNT(c_custkey when n_name = ’GERMANY’), COUNT(
c_custkey)) as percentage;
# Gold SQL: SELECT CAST(SUM(IIF(T2.n_name = ’GERMANY’, 1, 0)) AS REAL) * 100 / COUNT
(T1.c_custkey) FROM customer AS T1 INNER JOIN nation AS T2 ON T1.c_nationkey =
T2.n_nationkey
# Question: Among the schools whose donators are teachers, what is the percentage of
schools that are in Brooklyn?
# Knowledge Evidence: donors are teachers refers to is_teacher_acct = ’t’; Brooklyn
is school_city; percentage = Divide(Count(school_city-’Brooklyn’),Count(
school_city))*100
# Gold SQL: SELECT CAST(SUM(CASE WHEN T1.school_city LIKE ’Brooklyn’ THEN 1 ELSE 0
END) AS REAL) * 100 / COUNT(T1.teacher_acctid) FROM projects AS T1 INNER JOIN
donations AS T2 ON T1.projectid = T2.projectid WHERE T2.is_teacher_acct = ’t’
...
&lt;/examples&gt;

### SQLite SQL tables, with their properties:
# molecule ( molecule_id, label )
# bond ( bond_id, molecule_id, bond_type )
#
# bond.molecule_id = molecule.molecule_id
### The type and description of each column:
# [molecule]
- molecule_id (text): unique id of molecule
- label (text): whether this molecule is carcinogenic or not
# [bond]
- bond_id (text): unique id representing bonds
- molecule_id (text): identifying the molecule in which the bond appears
- bond_type (text): type of the bond
### Sample rows of each table in csv format:
# [molecule]
molecule_id,label
TR000,+
TR001,+
TR002,-
# [bond]
bond_id,molecule_id,bond_type
TR000_1_2,TR000,-
TR000_2_3,TR000,-
TR000_2_4,TR000,-

### Question: Among all chemical compounds identified in the database, what percent
of compounds form a triple-bond.
### Knowledge Evidence: triple bond refers to bond_type = ’#’;
### Candidate SQLs:
1. SELECT CAST(COUNT(CASE WHEN bond_type = ’#’ THEN 1 ELSE NULL END) AS REAL) * 100
/ COUNT(*) FROM bond
2. SELECT CAST(COUNT(DISTINCT CASE WHEN bond_type = ’#’ THEN molecule_id ELSE NULL
END) AS REAL) * 100 / COUNT(DISTINCT molecule_id) FROM bond
### Checklist:
1. The SQL should accurately represent the question.
2. The SQL should accurately use the given knowledge evidence.
3. The SELECT clause should not include any additional columns that are not included
in the question.
4. The order of columns in the SELECT clause must be the same as the order in the
question.
5. Check if the operations are being performed correctly according to the column
type.
### Instruction:
- If the first SQL satisfies all the conditions of the checklist, please choose the
first SQL. If not, move on to the next SQL.
- If there’s no SQL that satisfies all the requirements on the checklist, just
choose the first SQL.
- Provide a detailed step-by-step explanation following the order of the checklist
when checking whether each SQL satisfies the checklist.
- Your answer should strictly follow the following json format.
{{
"reasoning": "", // The reasoning steps for choosing the best SQL.
"sql": "", // The final chosen SQL.
}}
### Your Answer:</code></pre>
</section>
</section>
</section>
<section id="experimental-setup" class="level1">
<h1>4. Experimental Setup</h1>
<section id="datasets" class="level2">
<h2 class="anchored" data-anchor-id="datasets">4.1 Datasets</h2>
<ul>
<li>Spider : 10,181 질문, 5,693개의 쿼리, 200 DBs</li>
<li>BIRD : 12,751 질문-SQL pairs, 95 DB. 더 복잡한 쿼리가 포함되어 있음.</li>
</ul>
</section>
<section id="evaluation-metrics" class="level2">
<h2 class="anchored" data-anchor-id="evaluation-metrics">4.2 Evaluation Metrics</h2>
<ul>
<li>Execution Accuracy(EX) : 생성한 SQL 실행결과가 gold SQL query(answer) 실행결과가 같은지</li>
<li>Valid Efficiency Score(VES) : BIRD에서 추가로 제시. EX에 gold SQL query 실행 시간과 얼마나 다른지 추가. 정확성과 성능 측정</li>
</ul>
</section>
<section id="implementation-details" class="level2">
<h2 class="anchored" data-anchor-id="implementation-details">4.3 Implementation Details</h2>
<ul>
<li>LLM 모델 : GPT-4</li>
<li>임베딩 모델 : text-embedding-ada-002</li>
<li>similarity search : FAISS</li>
<li>schema linking(table, column) prompts <span class="math inline">\(p_t\)</span>, <span class="math inline">\(p_c\)</span> : 3개</li>
<li>SQL generation prompts <span class="math inline">\(p_q\)</span> : 5개</li>
<li>각 GPT API call 마다 temperature 1.0, n=20 응답 생성</li>
<li>SQL-generation, MCS 에는 k=20개의 question-SQL pairs를 few-shot example로 사용.</li>
<li>타임아웃 180초</li>
<li>confidence score threshold 0.2</li>
</ul>
</section>
</section>
<section id="results-and-analysis" class="level1">
<h1>5. Results and Analysis</h1>
<ul>
<li>Schema Linking에서 다양한 prompts 사용은 확실히 도움 된다. BIRD 기준 prompt 1개, response 1개 - 61.3, prompt 1개, response 20개 - 77.1, prompt 3개, response 20개 - 89.8</li>
<li>Example Selection에서 Masked Question Similarity는 조금 도움된다. BIRD 기준 Random 57.0, Question Similarity 59.3, Masked Question Similarity 60.0</li>
<li>MCS는 아주 조금 좋아진다. BIRD 기준 Majority Vote 62.8, MCS without confidence filtering 62.5, MCS with confidence filtering 63.4 (솔직히 비용에 비해 큰 상승 없는 것 같음)</li>
</ul>
</section>
<section id="a.-error-analysis" class="level1">
<h1>A. Error Analysis</h1>
<p>생성 SQL의 실행결과가 Gold SQL 실행결과가 틀린경우 분석 (BIRD 기준)</p>
<ul>
<li>Incorrect Gold : answer가 틀린 경우 28%</li>
<li>Semantically Correct : 컬럼 순서나 추가적인 컬럼이 있는 경우 34%</li>
<li>Schema-linking Error : 다른 컬럼, 테이블 선택 20%</li>
<li>그 외 에러 : 18%</li>
<li>62% 정도가 Gold SQL이 잘못됐거나 의미적으로 같은데 실패했다고 판정한 경우</li>
<li>20%는 Schema-linking error 인데, 사람조차도 테이블과 컬럼에 대해 모호성으로 틀릴 수 있음. 같은 뜻을 가진 컬럼이나 질문이 컬럼을 특정하지 못하는 경우.</li>
<li>나머지 18%는 질문이나 증거를 잘못 해석하거나, DB 데이터에 대한 잘못된 가정, 문법 에러 등이 있었다.</li>
<li>이런 이유들로 EX 평가는 매우 과소평가가 된다. text-to-SQL에서는 정확한 Gold SQL을 만들어야 하고 평가 방법을 더 정교하게 만들어야한다.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>