{
  "hash": "8cabe038c620da266bd4be20f090ef94",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"DeepSeek-R1 Paper Review\"\nauthor: \"Jaehyeok Lee\"\ndate: \"2025-02-22\"\nformat: \n  html:\n    code-overflow: wrap\ncategories:\n  - LLM\n---\n\n\nDeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning\n[https://arxiv.org/pdf/2501.12948](https://arxiv.org/pdf/2501.12948)\n\n\n# Abstract\n- DeepSeek-R1-Zero, DeepSeek-R1 소개\n- DeepSeek-R1-Zero는 SFT없이 RL만으로 학습. 추론 능력은 엄청 좋아지지만 가독성이나 언어 섞임 문제가 있음.\n- DeepSeek-R1은 이 문제를 방지하기 위해 RL전에 cold-start data 수집 및 multi-state training를 수행.\n\n# 1. Introduction\n- 순수 RL로 추론 능력(reasoning capabilities)를 갖출 수 있음.\n- DeepSeek-R1-Zero : DeepSeek-V3-Base를 base model로 하고 GRPO를 학습 알고리즘으로 사용.\n- DeepSeek-R1 : DeepSeek-V3-Base를 수 천(thousands of)의 cold-start data로 fine-tune을 하고, DeepSeek-R1-Zero 처럼 RL을 수행. RL이 수렴에 가까워지면, RL checkpoint에서 rejection sampling을 통해 새 SFT data를 만들고, DeepSeek-V3를 학습시켰던 데이터(writing, factual QA, and self-cognition)와 합친 후 DeepSeek-V3-Base model을 재학습(SFT). fine-tuing 이후 모든 시나리오의 prompts에 대해 RL. 이렇게 하면 o1-1217을 능가.\n- Qwen2.5-32B에 RL을 적용하는 것보다 DeepSeek-R1에서 직접 증류하는 것이 성능이 더 좋다.\n\n## 1.1 Contributions\nPost-Training: Large-Scale Reinforcement Learning on the Base Model\n\n- DeepSeek-R1-Zero는 SFT 없이 RL 만으로 복잡한 문제에 대해 chain-of-thought(CoT)를 진행함. 모델은 self-verification, reflection, generating long CoTs를 설명한다. LLM이 pure RL로도 reasoning capabilities가 강화되는 것을 보여준다.\n- Reasoning pattern을 강화하고 human preferences를 조절하는 것을 목표로 하는 2번의 RL, 모델의 reasoning and non-reasoning capabilities 역할을 추가하는 2번의 SFT pipline을 소개.\n\nDistillation: Smaller Models Can be Powerful Too\n\n- 큰 reasoning model에서 작은 model로 distillation을 하는 것은 작은 model이 RL 하는 것보다 성능이 좋다.\n- DeepSeek-R1으로 생성한 reasoning data로 널리 사용되는 model을 fine-tune 했다.\n\n# 2 Approach\n## 2.1 Overview\n- DeepSeek-R1-Zero : RL만 사용해서 reasoning capabilities 상승\n- DeepSeek-R1 : 작은 cold-start data(long Chain-of-Thought)와 RL로 성능 더 상승\n- Distill the reasoning capability from DeepSeek-R1 to small dense models\n\n## 2.2 DeepSeek-R1-Zero: Reinforcement Learning on the Base Model\n### 2.2.1 Reinforcement Learning Algorithm\nGRPO (Group Relative Policy Optimization)\n\n- Training cost를 절약하기 위해 policy model의 크기와 동일한 critic model을 포기하고 group scores를 측정하는 GRPO를 도입.\n- 질문 $q$에 대해 GRPO는 old policy $\\pi_{\\theta_\\text{OLD}}$의 outputs $\\{o_1, o_2, \\cdots, o_G\\}$를 구하고 다음의 objective function을 최대화를 해서 policy model $\\pi_\\theta$를 최적화한다.\n$$\n\\mathcal{J}_{\\text{GRPO}}\n= \\mathbb{E}[q \\sim P(Q), \\{o_i\\}_{i=1}^{G} \\sim \\pi_{\\theta_\\text{OLD}}(O|q)] \n$$\n$$\n\\frac{1}{G} \\sum_{i=1}^G\n\\left(\n\\text{min} \\left(\n\t\\frac{\\pi_\\theta(o_i|q)}{\\pi_{\\text{old}}(o_i|q)}A_i,\n\t\\text{clip} \\left(\\frac{\\pi_\\theta(o_i|q)}{\\pi_{\\text{old}}(o_i|q)}, 1-\\epsilon, 1+\\epsilon \\right) A_i\n\\right) - \\beta \\; \\mathbb{D}_{KL}(\\pi_\\theta || \\pi_{ref})\n\\right)\n$$\n$$\n\\mathbb{D}_{KL}(\\pi_\\theta || \\pi_{ref}) =\n\\frac{\\pi_{ref}(o_i|q)}{\\pi_\\theta(o_i|q)} -\n\\text{log} \\frac{\\pi_{ref}(o_i|q)}{\\pi_\\theta(o_i|q)} - 1\n$$\n- $\\epsilon$과 $\\beta$는 hyper-parameters\n- $A_i$는 a group of rewards $\\{r_1, r_2, \\cdots, r_G\\}$로 계산한 advantage \n$$\nA_i = \\frac{r_i - \\text{mean}(\\{r_1, r_2, \\cdots, r_G\\})}\n{\\text{std}(\\{r_1, r_2, \\cdots, r_G\\})}\n$$\n\n### 2.2.2 Reward Modeling\n- reward는 RL의 최적화 방향을 결정\n- DeepSeek-R1-Zero는 2가지 rule-based reward system을 구성\n- Accuracy rewards : response가 맞는지 체크. 수학 문제의 경우 특정 박스 안에 출력해서 답 비교, LeetCode 문제의 경우 test cases를 가지고 피드백을 생성가능. (compiler도 사용)\n- Format rewards : `<think>`, `</think>` tag 사이에 생각을 하도록 강제하는 reward model도 사용\n- 메모) SFT의 경우 답변 스크립트를 모두 작성하는 것을 기준으로 한듯. RL은 마지막 최종 답(수학, 코딩문제)를 비교해서 맞으면 reward.\n- outcome reward model를 추가적으로 사용하지 않음. (비용 등 문제)\n\n### 2.2.3 Training Template\n\n::: {#4659a7dd .cell execution_count=1}\n``` {.python .cell-code}\nprompt = \"\"\"\nA conversation between User and Assistant. The user asks a question, and the Assistant solves it. The assistant first thinks about the reasoning process in the mind and then provides the user with the answer. The reasoning process and answer are enclosed within <think> </think> and <answer> </answer> tags, respectively, i.e., <think> reasoning process here </think> <answer> answer here </answer>.\nUser: prompt.\nAssistant:\n\"\"\"\n```\n:::\n\n\n- 위와 같은 template로 reasoning process를 생성하고 최종 답을 내놓는다.\n- 이 구조적 제약은 content-specific bias(reflective reasoning - 반성적 추론을 강제하거나 특정 문제 해결 전략을 promoting 하거나 등)를 피하고 자연스러운 추론을 관찰하기 위해 추가.\n- 메모) 알고리즘 문제 테스트했을때 DP만 계속 생각하더라\n\n### 2.2.4 Perpformance, Self-evolution Process and Aha Moment of DeepSeek-R1-Zero\n\nPerformance of DeepSeek-R1-Zero\n\n- RL만으로 AIME 2024 pass@1 score는 15.6% -> 71.0%로 급격한 상승을 보여줌. o1-0912(74.4%)에 근접해짐.\n\nSelf-evolution Process of DeepSeek-R1-Zero\n\n- RL로 학습하면 할 수록 response의 길이가 점점 증가한다 -> 자연스럽게 thinking time을 늘린다. (스스로 진화)\n- 또한 명시적으로 프로그래밍을 하지 않아도 reflection(심사숙고, model이 전단계를 다시 평가하는 것)과 다른 방법을 찾아보는 것이 생겨남.\n\nAha Moment of DeepSeek-R1-Zero\n\n- 모델 학습 중간 버전에서 \"aha moment\"가 나타남. 이 순간 DeepSeek-R1-Zero는 생각할 시간을 가지고 앞서 내놓았던 방법을 재평가 한다. 이 행동은 reasoning 능력이 자라나고 있다는 것 뿐만 아니라 RL이 예상치 못한 정교한 결과를 이끄는 것을 보여준다.\n- 모델에 명시적으로 문제를 푸는 방법을 가르치는 것 보다 적절한 인센티브를 주면 자율적으로 문제 해결 전략을 배운다.\n\nDrawback of DeepSeek-R1-Zero\n\n- 강력한 추론 능력을 보이고 자체적으로 이 능력을 개발하지만 가독성 문제와 언어 섞임 문제가 있다.\n\n## 2.3 DeepSeek-R1: Reinforcement Learning with Cold Start\n두가지 의문점\n- 소량의 고품질 데이터로 cold start를 사용하면 성능이 더 오를까?\n- 명확하고 일관된 CoT를 생성하고 강력한 일반적인 역량(general capabilities)을 보려주려면 어떻게 user-friendly model을 학습시킬까?\n- 메모) DeepSeek-R1은 OpenAI의 o1으로 distillation 했다는 것이 강하게 의심됨. SFT 데이터는 o1으로 만들었을 가능성이 높음.\n\n### 2.3.1 Cold Start\n- 불안정한 RL cold start을 막기위해 DeepSeek-R1에서는 fine-tuning 용 긴 CoT data을 수집해 초기 RL actor를 만든다.\n- 데이터 수집 방법 : long CoT를 가진 few-shot prompting, reflection과 verification을 생성하도록 요구하는 prompting, DeepSeek-R1-Zero outputs을 읽을 수 있는 포맷으로 만들기, human annotators로 결과를 후처리\n- 이 방법으로 수천 개의 데이터를 수집하고 DeepSeek-V3-Base를 fine-tuning, RL의 시작점.\n- 장점1, 가독성 : cold-start data를 만들때 response 끝에 요약을 추가한 가독성 있는 패턴을 설계, 어색한 response는 필터링. output format을 `|special_token|<reasoning_process>|special_token|<summary>,`로 정의.\n- 장점2, 잠재성 : 인간의 사전 지식으로 신중하게 패턴을 설계해서 DeepSeek-R1-Zero를 이김. Reasoning model은 반복학습이 더 효과적임.\n\n### 2.3.2 Reasoning-oriented Reinforcement Learning\n- DeepSeek-V3-Base를 cold-start data로 fine-tuning 후 DeepSeek-R1-Zero 처럼 RL 수행. 잘 정의된 문제와 답(코딩, 수학, 과학, 논리 추론)과 같은 reasoning-intensive tasks를 학습해서 추론 능력을 향상시키는데 집중.\n- RL prompts에 여러 언어가 있을 경우 학습 중에 CoT에서 언어 섞임 문제를 발견. 이를 완화하려고 CoT에서 target language의 proportion으로 language consistency reward를 도입. 이런 조정이 다소 모델 성능을 떨어뜨리지만 가독성을 높임.\n- reasoning task의 정확도와 language consistency reward를 더해서 최종 reward를 만듬. 그리고 수렴할때까지 학습.\n\n### 2.3.3 Rejection Sampling and Supervised Find-Tuning\n- 앞의 RL가 수렴하면 이 checkpoint를 가지고 SFT 데이터를 모은다.\n- 이 단계에서는 일반적인 task를 강화하기 위한 데이터를 추가한다.\n\nReasoning data\n\n- Reasoning prompts를 만들고 앞에서 만든 RL checkpoint 모델의 outputs을 rejection sampling을 했다.\n- 이 단계에선 추가적인 데이터가 있음. 여기서 데이터셋을 확장하는데, 일부는 DeepSeek-V3에 정답(ground-truth)과 모델 예측을 입력해 DeppSeek-V3의 판단을 reward로 사용. (generative reward model, 개인적으로 이 ground-truth가 OpenAI o1의 response라고 생각한다.)\n- 읽기 어려운 output은 제외. 각 prompt마다 옳은 response만 유지. 600K training samples를 모음.\n\nNon-Reasoning data\n\n- DeepSeek-V3의 SFT dataset의 부분을 재사용. 어떤 non-reasoning data에 대해 DeepSeek-V3에 prompting으로 CoT response 요구. 여기서 200K training samples를 모음.\n\n여기서 모은 800K samples로 DeepSeek-V3-Base를 2 epoch로 fine-tuning함.\n\n### 2.3.4 Reinforcement Learning for all Scenarios\n- reward의 조합과 다양한 프롬프트 분포를 사용해 RL -> helpfulness, harmlessness, reasoning capabilities\n- Reasoning data는 DeepSeek-R1-Zero 처럼, 일반적인 data는 human preferences를 캐치하도록 DeepSeek-V3 처럼 preference pairs로 학습.\n- helpfulness를 위해 summary에 집중. reasoning process를 방해를 최소화하기 위해 response와 user 사이 관련성, 효용성 집중.\n- harmlessness를 위해 reasoning process와 summary를 포함한 모든 response를 평가.\n- 궁극적으로 reward 조합과 데이터 분포의 다양함은 도움됨.\n\n## 2.4 Distilation: Empower Small Models with Reasoning Capability\n- DeepSeek-R1의 800k samples를 가지고 Qwen, Llama를 SFT만(RL 없이) 해도 reasoning abilities를 향상시킴.\n\n# 3 Experiment\n\nBenchmarks : 다양한 벤치마크 사용\n\nEvaluation Prompts\n\nBaselines\n\nEvaluation Setup\n\n- maximum generation length : 32,768 tokens\n- long-output reasoning models를 평가하는데 greedy decoding을 사용하는 것은 높은 반복율(똑같은 답변), checkpoints간에 변동성이 크다는 것을 확인. 그래서 기본적으로 pass@k 평가 사용, pass@1은 non-zero temperature 사용.\n- sampling temperature 0.6, top-p 0.95, test set size에 따라 4~64 k responses\n- Pass@1은 아래와 같이 계산, $p_i$는 i-th response가 맞는지 체크.\n$$\n\\text{pass@1} = \\frac{1}{k} \\sum_{i=1}^k p_i\n$$\n\n## 3.1 DeepSeek-R1 Evaluation\n- 여러가지 Benchmarks에서 좋아졌다.\n\n## 3.2 Distilled Model Evaluation\n- Dilstilled 7B는 GPT-4o-0513 이김. Distilled 14B는 Qwwq-32B-preview 이김. Dilstilled 32B, 70B는 o1-mini 이김.\n- 이 distilled model에 추가적인 RL을 적용하면 성능이 더 올라간다. 추가 실험 필요해서 SFT한 결과만 남긴다.\n\n# 4. Discussion\n\n## 4.1 Distilation vs Reinforcement Learning\n- distilation 없이 RL만 한 것은 distilation만 한 것보다 성능이 낮다.\n- 강력한 모델로 작은 모델에 distilation 하는 것이 가장 좋은 결과를 얻었다. 작은 모델을 large-scale RL을 한 것은 큰 연산을 요구하나 distilation 성능보다 낮다.\n- distilation은 경제적이고 효과적이나, 지식의 한계점을 돌파하려면 더 강력한 base model과 더 큰 scale의 RL이 필요하다.\n\n## 4.2 Unsuccessful Attempts\n시도했으나 실패한 것. 이 방법으로 불가능하다는 뜻이 아님.\n\nProcess Reward Model (PRM)\n\n- 현실적으로 세 가지 이유 때문에 힘듬. 1) 일반적인 reasoning에서 세밀한 단계를 정의하는 것, 2) 중간 단계가 맞는지 체크, 3) Reward Hacking 가능하고 재학습이 어려움.\n- PRM은 top-N responses를 재정렬하거나 guided search에서 도움이 됨.\n\nMonte Carlo Tree Search (MCTS)\n\n- 특정한 reasoning 단계를 검색하기 위해 여러 태그를 생성. 학습을 위해 pre-trained value model에 의한 MCTS로 수집된 prompts의 답을 생성. 그리고 actor, value model을 학습.\n- chess랑 다르게 token generation은 search space가 더 크다. node 확장 수를 제한하니까 local optima에 갖힘. \n- fine-grained value model을 학습시키는 것은 어려움 -> search process에 영향\n\n# 5 Conclusion, Limitations, and Future Work\n\n",
    "supporting": [
      "deepseek_r1_files"
    ],
    "filters": [],
    "includes": {}
  }
}